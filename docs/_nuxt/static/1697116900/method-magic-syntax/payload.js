__NUXT_JSONP__("/method-magic-syntax", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z){return {data:[{page:{slug:p,description:"where('status', 1) или whereStatus(1)",heading:"Магический синтаксис",altHeadings:"Laraway",toc:[],body:{type:q,children:[{type:b,tag:h,props:{},children:[{type:a,value:r},{type:b,tag:s,props:{to:t},children:[{type:a,value:u}]},{type:a,value:v}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:w},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:x}]},{type:a,value:f},{type:a,value:f},{type:b,tag:l,props:{name:"cases\u002Fmethod-magic-syntax\u002Fwhere-regular"},children:[]},{type:a,value:f},{type:b,tag:l,props:{name:"cases\u002Fmethod-magic-syntax\u002Fwhere-magic"},children:[]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"\n  Обычно у разработчиков первая реакция\n  "},{type:b,tag:c,props:{className:[y]},children:[{type:a,value:"\"ух ты, а так можно было?\""}]},{type:a,value:". Да, действительно так "},{type:b,tag:"b",props:{},children:[{type:a,value:"можно, но не нужно"}]},{type:a,value:z}]},{type:a,value:f},{type:b,tag:o,props:{heading:"Читаемость кода",id:"readability"},children:[{type:a,value:i},{type:b,tag:h,props:{},children:[{type:a,value:"\n    Сначала код может показаться более \"гладким\", но выглядит он так только в простых примерах,\n    с простыми именами полей. Когда условий значительно больше, а имена становятся реальными,\n    то читаемость кода падает.\n  "}]},{type:a,value:i},{type:b,tag:h,props:{},children:[{type:a,value:"\n    В первом примере (обычный синтаксис) мы можем очень быстро, не вчитываясь, пробежаться глазами\n    и найти все "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:" и поля по которым происходит выборка.\n    Это происходит благодаря визуальному отделению имени поля от имени метода и помогает в этом ещё и подсветка.\n  "}]},{type:a,value:i},{type:b,tag:h,props:{},children:[{type:a,value:"\n    Во втором примере, нам придётся вчитываться в название метода и искать\n    где заканчивается where и начинается имя колонки, и подсветка нам в этом не поможет.\n  "}]},{type:a,value:i},{type:b,tag:h,props:{},children:[{type:a,value:"\n    Субъективно, скажешь ты? Ок, двигаемся дальше.\n  "}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:o,props:{heading:"Поддержка IDE",id:"ide"},children:[{type:a,value:i},{type:b,tag:h,props:{},children:[{type:a,value:"\n    Следующая проблема альтернативного синтаксиса - это поддержка IDE. На сегодняшний день существует плагин, который\n    понимает такие методы, но позиция "},{type:b,tag:c,props:{className:[y]},children:[{type:a,value:"\"нужен плагин, чтобы работать с фреймворком\""}]},{type:a,value:" слабая.\n    Может лучше писать так, что бы код можно было поддерживать не привязываясь к IDE и плагинам?\n    Понимаю, когда иначе никак не написать или вариант превосходит в своей полезности, но в данном случае это не так.\n  "}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:o,props:{heading:"Конфликт методов",id:"conflict"},children:[{type:a,value:i},{type:b,tag:h,props:{},children:[{type:a,value:"\n    И самая главная проблема - конфликт с \"реальными\" методами QueryBuilder-а. Например:\n  "}]},{type:a,value:i},{type:b,tag:h,props:{},children:[{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereDate()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereTime()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereMonth()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereDay()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereYear()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereColumn()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereKey()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereExists()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereFullText()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereNot()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereHas()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereIn()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereBetween()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereJsonContains()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereNested()"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:"whereSub()"}]},{type:a,value:i}]},{type:a,value:i},{type:b,tag:h,props:{},children:[{type:a,value:"\n    И это не полный список, который может дополняться с обновлениями фреймворка.\n    Маловероятно, что в БД будут поля с именами has или in, но такая вероятность всегда есть. А, например,\n    date, time, month, day, year, key, full_text встречаются достаточно часто. В данном случае будут вызваны методы фреймворка и\n    чтобы сделать выборку по полю, придётся писать обычный "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:", что делает код разностилевым\n    и как следствие напрашивается логичный вариант - писать в одном стиле.\n  "}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"\n  Я не буду отговаривать использовать \"магический синтаксис\", каждый делает выводы для себя сам,\n  но не вижу ни одного плюса, чтобы отказаться от обычного "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:z}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"\n  Тем не менее есть места, где \"магический синтаксис\" выглядит уместно и не доставляет проблем, например, в response:\n"}]},{type:a,value:f},{type:b,tag:l,props:{name:"cases\u002Fmethod-magic-syntax\u002Fwith-regular"},children:[]},{type:a,value:f},{type:b,tag:l,props:{name:"cases\u002Fmethod-magic-syntax\u002Fwith-magic"},children:[]}]},excerpt:{type:q,children:[{type:b,tag:h,props:{},children:[{type:a,value:r},{type:b,tag:s,props:{to:t},children:[{type:a,value:u}]},{type:a,value:v}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:w},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:x}]}]},dir:"\u002Fcases",path:"\u002Fcases\u002Fmethod-magic-syntax",extension:".md",createdAt:"2022-08-15T13:41:49.952Z",updatedAt:"2022-08-15T22:14:35.960Z"},id:p}],fetch:{"CodeChips:0":{_error:{message:"request to http:\u002F\u002Flocalhost:3000\u002F_content\u002Fcode-chips\u002Fout\u002Fcases\u002Fmethod-magic-syntax\u002Fwhere-regular.md failed, reason: connect ECONNREFUSED 127.0.0.1:3000",type:m,errno:j,code:j,statusCode:n}},"CodeChips:1":{_error:{message:"request to http:\u002F\u002Flocalhost:3000\u002F_content\u002Fcode-chips\u002Fout\u002Fcases\u002Fmethod-magic-syntax\u002Fwhere-magic.md failed, reason: connect ECONNREFUSED 127.0.0.1:3000",type:m,errno:j,code:j,statusCode:n}},"CodeChips:2":{_error:{message:"request to http:\u002F\u002Flocalhost:3000\u002F_content\u002Fcode-chips\u002Fout\u002Fcases\u002Fmethod-magic-syntax\u002Fwith-regular.md failed, reason: connect ECONNREFUSED 127.0.0.1:3000",type:m,errno:j,code:j,statusCode:n}},"CodeChips:3":{_error:{message:"request to http:\u002F\u002Flocalhost:3000\u002F_content\u002Fcode-chips\u002Fout\u002Fcases\u002Fmethod-magic-syntax\u002Fwith-magic.md failed, reason: connect ECONNREFUSED 127.0.0.1:3000",type:m,errno:j,code:j,statusCode:n}}},mutations:[]}}("text","element","span","bit","code","\n","\n    ","p","\n  ","ECONNREFUSED","where()","code-chips","system",500,"case-context-section","method-magic-syntax","root","\n  Laravel - фреймворк с лаконичным синтаксисом и местами он пытается угодить всем,\n  предоставляя разные способы написания одного и того же кода,\n  что часто приводит к ","nuxt-link","\u002Fintro\u002F","«laraway»"," спорам.\n","\n  Здесь я хочу рассмотреть сомнительную функциональность, которой нет в документации, но тем не менее её применяют -\n  это магические методы, речь не про саму \"магию\" в php, а про альтернативный синтаксис некоторых методов, например,\n  "," \n","italic",".\n")));